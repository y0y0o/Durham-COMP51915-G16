# Durham-COMP51915-G16
This repository is for Durham University course name COMP51915-Professional Skills of Group 16. We will collaborate. The aim of this project is to collaboratively design and implement a **console-based Gomoku (Five-in-a-Row)** game using modern C++, while applying professional software engineering practices including:

- Git version control & collaboration  
- Unit testing  
- Coding standards & formatting  
- Continuous Integration (GitHub Actions)  
- Modular software design  

---

## 1. Project Overview

This project implements a modular, test-driven Gomoku (Five-in-a-Row) game in modern C++17 as part of the COMP51915 – Professional Skills module at Durham University. The objective of the assignment is not only to build a functioning game, but also to demonstrate competence in professional software engineering practices, including version control, collaborative development, modular system design, automated testing, and continuous integration.

**Gomoku** is a classical two-player board game in which players alternately place stones on a square grid. The goal is to achieve **five consecutive stones** horizontally, vertically, or diagonally. Although the rules are simple, implementing Gomoku in a clean and maintainable way requires careful separation of responsibilities and robust game-state management.

To meet these requirements, our implementation adopts a structured architecture that separates low-level board representation from high-level game flow. System correctness is supported by a comprehensive unit test suite, while development quality is enforced through automatic formatting (clang-format) and a GitHub Actions CI pipeline.

Key characteristics of the project include:

- a well-structured C++17 codebase with clear modular boundaries  
- separation of concerns between the `Board` and `Game` components  
- deterministic win-detection logic covering all directional cases  
- a terminal-based user interface for interactive gameplay  
- unit tests verifying both board behaviour and game mechanics  
- automated linting and CI checks to maintain code quality across the team

This combination of gameplay functionality and engineering workflow demonstrates our application of real-world development practices within the context of a collaborative coursework project.
---

## 2. Features

Our Gomoku implementation is designed not only to reproduce the rules of the game, but also to reflect good software engineering practice. The features of the project can be categorised into three domains: gameplay functionality, system architecture, and engineering workflow.

### Gameplay Features
- **Two-player interactive gameplay** with alternating turns.
- **Configurable board representation** (default 15×15) stored in a clean 2D structure.
- **Input validation** preventing illegal moves such as out-of-bounds coordinates or occupied positions.
- **Deterministic win-detection algorithm** capable of identifying horizontal, vertical, and diagonal five-in-a-row patterns.
- **Clear terminal-based user interface** providing real-time board updates.

### Architectural Features
- **Separation of concerns** through distinct `Board` and `Game` classes.
- `Board` handles:
  - stone placement  
  - grid boundaries  
  - directional win checks  
- `Game` manages:
  - turn order  
  - player interaction  
  - integration of board logic  
- **Maintainable, modular C++17 design**, facilitating readability and extensibility.

### Testing Features
- **Unit tests for the Board component**, covering:
  - placement rules  
  - boundary enforcement  
  - all directional win cases  
- **Unit tests for the Game component**, validating:
  - turn switching  
  - game flow logic  
  - end-game detection
- Tests provide confidence in correctness and guard against regressions.

### ⚙ Engineering Workflow Features
- **clang-format enforcement** ensuring consistent coding style across the team.
- **Makefile-based build system** supporting compilation, testing, and linting tasks.
- **GitHub Actions CI pipeline** that automatically:
  - compiles the project  
  - checks formatting compliance  
  - runs all unit tests
- This workflow mirrors industry-standard development pipelines and ensures stable collaboration.

---

## 3. Project Structure

The project follows a clean and modular directory layout that separates source code, test suites, build automation, and continuous integration configuration. This structure promotes maintainability, clarity, and scalability, aligning with standard practices in collaborative software development.


```bash
Durham-COMP51915-G16/
│
├── gomoku                   # Main game executable (generated by Makefile)
├── test_board               # Board test executable
├── test_game                # Game test executable
│
├── src/
│   ├── ai.cpp               # AI module implementation
│   ├── ai.h                 # AI module header
│   ├── board.cpp            # Board implementation
│   ├── board.h              # Board class header
│   ├── game.cpp             # Game implementation
│   ├── game.h               # Game logic header
│   └── main.cpp             # Program entry point
│
├── tests/
│   ├── test_board.cpp       # Unit tests for Board
│   └── test_game.cpp        # Unit tests for Game
│
├── .github/workflows/ci.yml # CI pipeline
├── Makefile                 # Build/test/lint rules
├── README.md                # Documentation
└── compile_commands.json    # (optional) clangd support

```
---

## 4. Build Instructions

The project uses a Makefile-based build system to ensure consistent compilation, testing, and formatting across all team members. The following instructions describe how to build and manage the project on a standard Linux-based development environment.

### Requirements
Ensure the following tools are installed:

- **g++** or **clang++** with C++17 support  
- **make** (build automation)  
- Linux / macOS / WSL environment  

These tools are readily available on most Unix-like systems and are standard in C++ development workflows.

---

### Build the Project

To compile the entire application, run:

```bash
make
```
This generates：
```bash
./test_board
./gomoku
./test_game
```
Execute the full unit test suite:
make test

Code formatting compliance
make lint-check


## 5.Running the Game

After building the project, the Gomoku game can be launched directly from the terminal.

### Start the Game

```bash
./gomoku
```
Players alternate by entering coordinates like:
Enter row and column: 7 8
The board updates automatically until a player wins.

## 6.Running Tests

The project includes a dedicated unit test suite that validates the correctness of both the Board and Game components. All tests are executed through the Makefile to ensure a consistent and automated workflow.

### ▶ Run the Entire Test Suite

```bash
make test
```
If needed, individual test executables can be run manually:
```bash
./test_board
./test_game
```
These tests verify:
valid and invalid stone placement
boundary handling
horizontal, vertical, and diagonal win detection
turn switching and game-state transitions

## 7.Code Style Checking

To maintain a consistent and professional coding style across the entire project, the repository enforces formatting rules using **clang-format**. All formatting-related operations are integrated into the Makefile and validated through the CI pipeline.

#### 7.1 Check Formatting Compliance

```bash
make lint-check
```
## 8.Continuous Integration (CI)

This project uses GitHub Actions to ensure that every commit and pull request is automatically validated for build correctness, code style compliance, and test success.

The CI workflow is defined in:
github/workflows/ci.yml


### What the CI Pipeline Checks

The automated workflow performs the following steps:

- Checks out the repository  
- Installs the required C++ toolchain  
- Builds all executables using the Makefile  
- Runs the full unit test suite  
- Verifiescode formatting via `make lint-check`  
- Reports failures directly on GitHub  

---

Using CI ensures:

- consistent build environments  
- early detection of errors  
- guaranteed formatting compliance  
- stable collaboration between team members  
- improved software quality and reliability  

The CI pipeline runs automatically for every push and pull request, ensuring the project remains in a verified working state at all times.


## 9. Team Members & Contributions

This project was collaboratively developed by four members of Group 16.  
Each member contributed to different aspects of the implementation, testing, documentation, and engineering workflow.

| Name | Contributions |
|------|--------------|
| **Waston Wan** | CI & Project Management<br/>- Designed and maintained the GitHub Actions CI pipeline for automated builds and testing.<br/>- Ensured every code commit triggered automatic compilation, test execution, and formatting checks;<br/>- When CI failed, pinpointed error sources (test logic or feature implementation), liaised with team members and assisted in resolution;<br/>- Managed overall workflow, including branch control and team coordination.<br/>- Assigned tasks and validated test results. |
| **Ethan** | Developed the unit tests for the Game module in test_game.cpp, verifying turn logic, invalid moves, and win-condition detection. Ensured that the test suite integrates with the existing C++ codebase and works seamlessly under the Makefile and CI workflow.|
| **Chen** | Chen led the complete debugging effort from the point where multiple automated tests were failing. He analyzed test expectations, identified discrepancies in input-parsing behavior, and rewrote the parseMove logic to correctly support all required formats. His work included resolving subtle cases such as "8 8" (number–number), "j10" (compact letter–number), and single-letter inputs. Chen also ensured that the code consistently passed all 13/13 automated tests and contributed to refining the README and project documentation. His contributions were critical to stabilizing the game’s core logic and achieving full test compliance. |
| **Zhenting** | In this five-in-a-row chess project, responsible for the overall system design and implementation, including the development of the game board module, game logic, human-computer interaction, and a simple AI. The project adopted a C++ multi-file structure. In the game module, functions such as player input parsing, illegal input handling, round switching, victory logic judgment, and re-starting the game were implemented. Additionally, the game includes modes for player-versus-player and player-versus-AI battles. A heuristic simple AI was designed and implemented, which can judge the game situation and make basic decisions, achieving the human-computer battle mode. |

---

### Collaboration Summary

- All members participated in discussions, design decisions, and pair-programming sessions.  
- Each member reviewed code written by others to ensure correctness and consistency.  
- Git history reflects active contributions in implementation, testing, debugging, formatting, and documentation.


